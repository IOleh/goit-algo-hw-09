## Висновки

### Приклад виконання

#### Для номіналу [50, 25, 10, 5, 2, 1]
Обидва алгоритми видають однаковий результат і різний час виконання:
Для суми 113   
`{50: 2, 10: 1, 2: 1, 1: 1}`
`{1: 1, 2: 1, 10: 1, 50: 2}`

Для суми 113113
Жадібний алгоритм:
`{50: 2262, 10: 1, 2: 1, 1: 1}`
Час виконання: `0.000000 секунд`

Динамічне програмування:
`{1: 1, 2: 1, 10: 1, 50: 2262}`
Час виконання: `0.081454 секунд`

#### Для для нестандартного набору номіналу [50, 25, 21, 10, 5, 3, 2, 1]
Для суми 113113 
Обидва алгоритми видають різний результат і різний час виконання:

Жадібний алгоритм: `{50: 2262, 10: 1, 3: 1}`
Час виконання: `0.000000 секунд`

Динамічне програмування: `{21: 3, 50: 2261}`
Час виконання: `0.198821 секунд`

---

### Оцінка ефективності алгоритмів

#### Жадібний алгоритм

- **Принцип роботи**: на кожному кроці вибирає найбільшу можливу монету, яка підходить для решти.
- **Часова складність**: \(O(n)\), де \(n\) – кількість доступних номіналів.
- **Переваги**:
  - Простий у реалізації.
  - Працює швидко для невеликих сум.
- **Недоліки**:  
  - Не завжди знаходить мінімальну кількість монет для нестандартних номіналів.

#### Динамічне програмування

- **Принцип роботи**: знаходить мінімальну кількість монет для всіх можливих проміжних сум (від 1 до заданої).
- **Часова складність**: \(O(n \cdot m)\), де \(n\) – кількість номіналів, \(m\) – сума.
- **Переваги**:
  - Завжди знаходить оптимальне рішення.
- **Недоліки**:  
  - Витрачає більше часу та пам'яті при великих значеннях суми.

---

### Висновки

- **Жадібний алгоритм** добре підходить для реальних випадків, коли номінали дозволяють швидко отримати решту (як у нашому прикладі [50, 25, 10, 5, 2, 1]). Проте, він може не спрацювати для складних наборів номіналів.
  
- **Динамічне програмування** гарантує оптимальне рішення, проте має більшу складність і може бути повільнішим для великих сум. Цей підхід більше підходить для нестандартних номіналів або ситуацій, коли важливо мінімізувати кількість монет.

---
